##图
- 二分查找
- 大 O 运行时间表示法，平均情况和最糟情况
 * O (log n ) 对数时间 --- 二分查找
 * O ( n ) 线性时间 --- 简单查找
 * O (n * log n ) 较快 --- 快排
 * O ( n ^ 2 ) n 方时间 --- 冒泡法
 * O ( n ！ ) 旅行商问题 --- 超慢
 * 运行时间也可以理解为栈的高度
- 选择排序
- 为什么排序算法重要？因为很多其他算法在经过排序后才能发挥作用
- 递归，递归的调用栈分析，关键理解每个调用栈都有自己的变量（变量名相同的情况下）
 * 实现并分析
- 快排
 * 分而治之：1680 * 640 土地，平均分成方块，每块最大为多少
 * 找出尽可能简单的基线条件，不断分解问题找到满足条件为止
 * 涉及到数组问题时，基线条件通常为：数组长度为 1 或者 0
- 散列表：DNS解析，将域名映射到ip地址;用作缓存
 * 实现:防止重复，仿真映射关系
 * 冲突:在数组的值处存放链表，最好做到均匀映射，这就对散列函数提出了一定的要求；装填因子，数组中已占用的位置，其值大于7，就要填奥正数组长度
 * 散列函数
- 广度优先算法用于非加权图中查找最短路径（路径段数最少）
 * 队列存放节点，散列表存放与临近节点的映射关系
 * 实现并分析
 * 可以找出是否有从 a 到 b 的路径，有则找出最短
 * 检查过的节点别再检查，可能无线循环
- 通过散列表存储节点信息，添加顺序不重要，散列表是无序的  
- 无向图相当于一个环图
- 算法步骤，将所有节点加入到队列中，当队列不为空的时候，将第一个成员出栈，不满足判断条件时，将它的子节点出栈
- 检查过的元素标记已检查
- 狄克斯特拉算法，没有负权边的情况下可以找出开销最小的路径，用于加权图中查找最短路径
 * 找出权重和最小路径，有环或者负权重将导致其失效
 * 换钢琴的问题
- 改进：贝尔曼福特算法
- 实现：散列表中可以继续包含散列表。一个表示整个图的表，一个路径开销表，一个存父节点的表，一个存放处理过节点的数组
- 贪婪算法，当没有任何算法能够快速解决问题时，求出近似解
 * 教室调度问题，背包问题
- 找出局部最优解
- 贪婪算法优劣的判断依据，速度有多快，与最优解的近似程度
- 创建一个包含所有州的 set 集合，一个广播台散列表，健为广播台名称，值为覆盖的州，一个存放答案的集合
- 具体
- NP问题：计算所有解，并找到最小或者最短的那个
 * 旅行商，集合覆盖
 * 涉及所有组合，涉及序列
- 动态规划，讲困难问题分解成小问题重点解决，作用是找最优解
- 前提是每个子问题之间不存在依赖
- 背包问题
- 从网格开始，单元格中存放要优化的值，每个单元格都是一个子问题
 * 逐步计算每个单元格的最大价值
- 最长公共子串问题
- 最长公共子序列问题
- 费曼算法：将问题写下来，好好思考，将答案写下来

